# 인터넷의 멀티미디어 배달부

우리에게 배달 서비스가 있듯이 웹에는 HTTP 라는 배달 서비스가 존재한다.

HTTP는 웹 서버로부터 대량의 정보를 빠르고, 간편하고, 정확하게 사람들에게 전달해 주는 배달부이며, 통신이 전송중 파괴되거나, 중복되거나 왜곡되는것을 걱정하지 않아도 되는 신뢰성 있는 배달부다.

배달 프로세스를 생각해보자.

제품을 제공하는 사람이 있고, 그 제품을 구매하는 사람이 있다. 이때, 구매한 제품을 전달하는게 배달부의 역할이다. 물건을 제공하는 사람은 발신자이며, 구매자는 수신자다. 그렇다면, 웹에서의 웹에서의 수신자와 발신자는 누굴까? 바로 클라이언트와 서버다.

<br/>
<br/>

# 웹 클라이언트와 서버

- 웹 콘텐츠는 웹 서버에 존재한다.
- 웹 서버는 HTTP로 통신하기 때문에 HTTP 서버라고도 불린다
- 웹 서버 === HTTP 서버
- HTTP 클라이언트 : 크롬, 엣지, 파이어폭스 …. 같은 웹 브라우저들

<br/>
<br/>

# 리소스

- 정적 리소스
- 동적 리소스

## 미디어 타입

배달작업을 효율적으로 하려면 분류작업이 먼저 이루어져야 한다. 그리고, 그 분류작업을 위해 우리는 카테고리를 형성하게 될 것이다. HTTP 도 마찬가지다. 수 많은 데이터를 전송하기 앞서, 해당 데이터들을 분류하는 작업을 한다. HTTP는 미디어 타입으로 분류작업을 진행한다.

### MIME 타입

- 데이터 포맷 라벨
- 원래는 이메일에서 사용됨 → 각기 다른 이메일 시스템에서 메시지가 잘 오가도록 하기 위해 설계됨
- HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택

  - 인터넷에는 다양한 데이터 타입을 다룬다. → 전송 객체에 각각 MIME 타입 붙여서 구분
  - 서버로부터 객체를 돌려받을 때 유효한 객체인지 MIME 타입으로 확인

- MIME 타입 = 주 타입 + 부 타입
  - HTML로 작성된 텍스트 문서 → text/html
  - plain ASCII 텍스트 문서 → text/plain
  - JPEG 이미지 → image/jpeg
  - GIF 이미지 → image/gif
  - 애플 퀵타임 동영상 → video/quicktime
  - ppt → application/vnd.ms-powerpoint

<br /> 
<br />

## URI

- 우편물 주소

분류작업을 마쳤으니, 이제 전달을 해보자. 우리가 배송지와 발송지를 작성하듯, 웹에서도 주소를 작성하여 데이터를 주고 받는다.

- 통합 자원 식별자(URI): 웹 서버 리소스는 각자 이름을 갖고 있는데 이를 일컫는 용어
- 정보 리소스를 고유하게 식별하고 위치 지정
- 종류
  - 통합 자원 지시자(**URL**) - 한 리소스에 대한 구체적인 위치 서술
    <img src="images/url.png" alt="url">
  - Scheme : 리소스에 접근하기 위해 사용되는 프로토콜
  - 유니폼 리소스 이름(**URN**)
    - 콘텐츠를 이루는 한 리소스에 대해 그 리소스의 위치에 영향을 받지 않는 유일무이한 이름
    - 위치 독립적인 URN은 리소스를 여기저기 옮겨도 문제없다.
    - 리소스 위치를 분석하기 위한 인프라 지원이 아직 부재해 아직 널리 채택되지 않고 있다.
      <img src="images/url_uri_urn.png" alt="url uri urn 비교">

<br /> 
<br />

# 트랜잭션

우리의 거래가 어떻게 이루어지는지 생각해보자.

소비자는 요청사항과 물품을 적어서 주문서를 작성하고 제출한다. 그러면 제공자는 주문서를 잘 받았는지, 배송중인지 물품 준비중인지, 다양한 정보를 소비자에게 제공하게된다.

웹도 마찬가지다. 클라이언트가 요청을 보내면, 서버는 클라이언트를 위해 다양한 정보들을 제공한다.

- 요청 명령 + 응답 메시지로 구성되어 있다.
- HTTP 메시지 라고 불리는 정형화된 데이터 덩어리를 이용해 이루어진다.
- 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행한다. → 웹페이지는 리소스의 모음

<br /> 
<br />

## 메서드

- 서버에게 어떤 동작이 취해져야 하는지 알려줌

| HTTP 메서드 | 설명                                                              |
| ----------- | ----------------------------------------------------------------- |
| GET         | 리소스 내놔                                                       |
| PUT         | 클라이언트에서 보낸 데이터를 지정한 이름의 리소스로 저장해 (수정) |
| POST        | 클라이언트 데이터를 서버 게이트웨이 어플리케이션으로 보내 (등록)  |
| DELETE      | 지정한 리소스를 서버에서 지워                                     |
| HEAD        | 지정한 리소스에 대한 응답에서 HTTP 헤더만 보내                    |

<br />

[참조] [mdn HTTP 요청 메서드](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/CONNECT)

<br /> 
<br />

## 상태 코드

- 클라이언트에게 요청이 성공했는지, 추가 조치가 필요한지 알려주는 세 자리 숫자
- 상태코드와 함께 사유 구절도 보내줌

| 상태코드 | 설명                             |
| -------- | -------------------------------- |
| 1xx      | 요청이 수신되어 처리중           |
| 2xx      | 요청 정상 처리                   |
| 3xx      | 요청을 완료하려면 추가 액션 필요 |
| 4xx      | 클라이언트 오류                  |
| 5xx      | 서버 오류                        |

<br />

[참조] [mdn HTTP 응답 상태 코드](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/100)

<br/>
<br/>

## 메세지

- 이진 형식이 아닌 텍스트, 줄 단위의 문자열 → 읽고 쓰기 쉬움

|                         | 요청 메세지                     | 응답메세지                  |
| ----------------------- | ------------------------------- | --------------------------- |
| 시작줄                  | GET /test/hi-there.txt HTTP/1.1 | HTTP/1.1 200 OK             |
| 헤더                    | Accept: text/\*                 |
| Accept-Language: en, fr | Content-type: text / plain      |
| Content-length: 19      |
| 본문                    |                                 | Hi! this is a test message! |

<br /> 
<br />

# TCP 커넥션

- HTTP는 애플리케이션 계층 프로토콜로 네트워크 통신의 세부사항에 대해서는 신경쓰지 않는다.

  → TCP/IP 에게 맡김 → TCP 커넥션을 통해 메시지를 한곳에서 다른 곳으로 옮긴다.

  → HTTP는 자신의 메시지를 전달하기 위해 TCP를 사용한다.

- 인터넷 자체가 대중적으로 사용되는 TCP/IP에 기초하고 있다.

  → 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해준다

  <br />

## TCP/IP

- 전송 제어 프로토콜
- 오류 없는 데이터 전송
- 순서 보장
- 조각나지 않는 데이터 스트림 → 언제든 어떤 크기로든 보낼 수 있음
- TCP 와 IP가 층을 이루는 패킷 교환 네트워크 프로토콜의 집합

### 접속, IP주소,그리고 포트번호

- HTTP 클라이언트가 서버에 메시지를 전송하기 위해 먼저 인터넷 프로토콜 주소(IP)와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 컨넥션을 맺어야 한다.
- 포트번호는 기본적으로 80이다
- 컴퓨터의 주소가 IP주소이며, 프로그램의 주소가 포트 번호

마치 회사에 전화해 회사 사무실 누군가에게 연결하는 과정과 비슷

→ 회사 번호 누른다 (IP)

→ 전화를 걸고자 하는 상대방이 쓰는 번호를 누른다(PORT 번호)

웹브라우저는 서버의 url에서 호스트 명을 추출

→ 호스트 명을 IP로 변환

→포트번호 추출

→ 웹 서버와 TCP 커넥션 맺는다

→ 웹브라우저는 서버에 TTHP 요청을 보낸다

→ 서버는 웹 브라우저에게 HTTP 응답을 보낸다.

→ 커넥션이 닫히면 웹 브라우저는 문서를 보여준다.

IP: **인터넷에 연결된 장치가 웹 서버와 통신하는 데 사용**

<br/>
<br/>
<br/>

### 텔넷(Telnet)

- 원격지의 호스트 컴퓨터에 접속하기 위해 사용되는 인터넷 프로토콜

```shell
telnet www.test.com 80//서버 연결
Trying 128.121.66.211...
Connected to test.com
Escape character is '^]' // 커넥션 수립됨
GET /tools.html HTTP/1.1 // 요청 명령
Host: test.com
```

<br/>
<br/>

## 프로토콜 버전

### HTTP/0.9

- 심각한 디자인 결함 있음
- 구식 클라이언트하고만 사용 가능
- GET 만 지원
- MIME 타입 지원 안함
- 간단한 HTML 객체를 받아오기 위함

### HTTP/1.0

- 처음으로 널리 쓰이게 된 버전
- HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리 추가
- 웹페이지와 상호작용하는 폼을 실현 → 월드 와이드 웹을 대세로 만들어줌

### HTTP/1.0+

1990년대 중반 월드 와이드 웹이 급격히 팽창하고 상업적으로 성공 → 그에 따른 요구를 만족시키기 위해 HTTP 기능 추가

- keep-alive 커넥션
- 가상 호스팅 지원
- 프락시 연결 지원

### HTTP/1.1

- HTTP 설계의 구조적 결함과 교정, 성능 최적화, 잘못된 기능 제거

### HTTP/2.0

- HTTP/1.1 성능 문제 개선하기 위해 구글의 SPDY 기반으로 설계

<br /> 
<br />

## 웹의 구성요소

### 프락시

- 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 보안, 애플리케이션 통합, 성능 최적화를 위한 중요한 구성요소
- 사용자를 대신해서 서버에 접근
- 응답과 요청 필터링 → 바이러스 검출, 성인 콘텐츠 차단 등등
- 주로 보안에 사용

### 캐시

- 클라이언트 가까이에 보관하는 HTTP 창고
- 웹 캐시와 캐시 프락시는 자신을 거쳐가는 문서들 중 자주 찾는 것의 사본을 저장해두는 HTTP vmfkrtm tjqj
- HTTP는 캐시를 효율적으로 동작하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 프라이버시도 보호하기 위해 많은 기능을 정의한다.

### 게이트웨이

- 다른 애플리케이션과 연결된 특별한 웹 서버
- 다른 서버들의 중개자로 동작하는 특별한 서버
- HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
- HTTP/FTP 게이트웨이는 HTTP 요청을 받아들인뒤 FTP 프로토콜로 문서를 가져온다.

### 터널

- 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 HTTP 어플리케이션
- 암호화된 SSL을 HTTP 커넥션으로 전달하여 웹 트래픽만 허용하는 사내 방화벽 통과시킴

### 에이전트

- 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트
- 스파이더, 웹로봇 등등
- 사람의 통제없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 콘텐츠를 받아오는 등등
